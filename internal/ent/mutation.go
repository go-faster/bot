// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/go-faster/bot/internal/ent/check"
	"github.com/go-faster/bot/internal/ent/gptdialog"
	"github.com/go-faster/bot/internal/ent/lastchannelmessage"
	"github.com/go-faster/bot/internal/ent/predicate"
	"github.com/go-faster/bot/internal/ent/prnotification"
	"github.com/go-faster/bot/internal/ent/telegramchannelstate"
	"github.com/go-faster/bot/internal/ent/telegramsession"
	"github.com/go-faster/bot/internal/ent/telegramuserstate"
	"github.com/go-faster/bot/internal/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCheck                = "Check"
	TypeGPTDialog            = "GPTDialog"
	TypeLastChannelMessage   = "LastChannelMessage"
	TypePRNotification       = "PRNotification"
	TypeTelegramChannelState = "TelegramChannelState"
	TypeTelegramSession      = "TelegramSession"
	TypeTelegramUserState    = "TelegramUserState"
	TypeUser                 = "User"
)

// CheckMutation represents an operation that mutates the Check nodes in the graph.
type CheckMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	repo_id            *int64
	addrepo_id         *int64
	pull_request_id    *int
	addpull_request_id *int
	name               *string
	status             *string
	conclusion         *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Check, error)
	predicates         []predicate.Check
}

var _ ent.Mutation = (*CheckMutation)(nil)

// checkOption allows management of the mutation configuration using functional options.
type checkOption func(*CheckMutation)

// newCheckMutation creates new mutation for the Check entity.
func newCheckMutation(c config, op Op, opts ...checkOption) *CheckMutation {
	m := &CheckMutation{
		config:        c,
		op:            op,
		typ:           TypeCheck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckID sets the ID field of the mutation.
func withCheckID(id int64) checkOption {
	return func(m *CheckMutation) {
		var (
			err   error
			once  sync.Once
			value *Check
		)
		m.oldValue = func(ctx context.Context) (*Check, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Check.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheck sets the old Check of the mutation.
func withCheck(node *Check) checkOption {
	return func(m *CheckMutation) {
		m.oldValue = func(context.Context) (*Check, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Check entities.
func (m *CheckMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Check.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepoID sets the "repo_id" field.
func (m *CheckMutation) SetRepoID(i int64) {
	m.repo_id = &i
	m.addrepo_id = nil
}

// RepoID returns the value of the "repo_id" field in the mutation.
func (m *CheckMutation) RepoID() (r int64, exists bool) {
	v := m.repo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoID returns the old "repo_id" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldRepoID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoID: %w", err)
	}
	return oldValue.RepoID, nil
}

// AddRepoID adds i to the "repo_id" field.
func (m *CheckMutation) AddRepoID(i int64) {
	if m.addrepo_id != nil {
		*m.addrepo_id += i
	} else {
		m.addrepo_id = &i
	}
}

// AddedRepoID returns the value that was added to the "repo_id" field in this mutation.
func (m *CheckMutation) AddedRepoID() (r int64, exists bool) {
	v := m.addrepo_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepoID resets all changes to the "repo_id" field.
func (m *CheckMutation) ResetRepoID() {
	m.repo_id = nil
	m.addrepo_id = nil
}

// SetPullRequestID sets the "pull_request_id" field.
func (m *CheckMutation) SetPullRequestID(i int) {
	m.pull_request_id = &i
	m.addpull_request_id = nil
}

// PullRequestID returns the value of the "pull_request_id" field in the mutation.
func (m *CheckMutation) PullRequestID() (r int, exists bool) {
	v := m.pull_request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestID returns the old "pull_request_id" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldPullRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestID: %w", err)
	}
	return oldValue.PullRequestID, nil
}

// AddPullRequestID adds i to the "pull_request_id" field.
func (m *CheckMutation) AddPullRequestID(i int) {
	if m.addpull_request_id != nil {
		*m.addpull_request_id += i
	} else {
		m.addpull_request_id = &i
	}
}

// AddedPullRequestID returns the value that was added to the "pull_request_id" field in this mutation.
func (m *CheckMutation) AddedPullRequestID() (r int, exists bool) {
	v := m.addpull_request_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPullRequestID resets all changes to the "pull_request_id" field.
func (m *CheckMutation) ResetPullRequestID() {
	m.pull_request_id = nil
	m.addpull_request_id = nil
}

// SetName sets the "name" field.
func (m *CheckMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CheckMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CheckMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *CheckMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CheckMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CheckMutation) ResetStatus() {
	m.status = nil
}

// SetConclusion sets the "conclusion" field.
func (m *CheckMutation) SetConclusion(s string) {
	m.conclusion = &s
}

// Conclusion returns the value of the "conclusion" field in the mutation.
func (m *CheckMutation) Conclusion() (r string, exists bool) {
	v := m.conclusion
	if v == nil {
		return
	}
	return *v, true
}

// OldConclusion returns the old "conclusion" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldConclusion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConclusion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConclusion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConclusion: %w", err)
	}
	return oldValue.Conclusion, nil
}

// ClearConclusion clears the value of the "conclusion" field.
func (m *CheckMutation) ClearConclusion() {
	m.conclusion = nil
	m.clearedFields[check.FieldConclusion] = struct{}{}
}

// ConclusionCleared returns if the "conclusion" field was cleared in this mutation.
func (m *CheckMutation) ConclusionCleared() bool {
	_, ok := m.clearedFields[check.FieldConclusion]
	return ok
}

// ResetConclusion resets all changes to the "conclusion" field.
func (m *CheckMutation) ResetConclusion() {
	m.conclusion = nil
	delete(m.clearedFields, check.FieldConclusion)
}

// Where appends a list predicates to the CheckMutation builder.
func (m *CheckMutation) Where(ps ...predicate.Check) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CheckMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CheckMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Check, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CheckMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CheckMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Check).
func (m *CheckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.repo_id != nil {
		fields = append(fields, check.FieldRepoID)
	}
	if m.pull_request_id != nil {
		fields = append(fields, check.FieldPullRequestID)
	}
	if m.name != nil {
		fields = append(fields, check.FieldName)
	}
	if m.status != nil {
		fields = append(fields, check.FieldStatus)
	}
	if m.conclusion != nil {
		fields = append(fields, check.FieldConclusion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case check.FieldRepoID:
		return m.RepoID()
	case check.FieldPullRequestID:
		return m.PullRequestID()
	case check.FieldName:
		return m.Name()
	case check.FieldStatus:
		return m.Status()
	case check.FieldConclusion:
		return m.Conclusion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case check.FieldRepoID:
		return m.OldRepoID(ctx)
	case check.FieldPullRequestID:
		return m.OldPullRequestID(ctx)
	case check.FieldName:
		return m.OldName(ctx)
	case check.FieldStatus:
		return m.OldStatus(ctx)
	case check.FieldConclusion:
		return m.OldConclusion(ctx)
	}
	return nil, fmt.Errorf("unknown Check field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case check.FieldRepoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoID(v)
		return nil
	case check.FieldPullRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestID(v)
		return nil
	case check.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case check.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case check.FieldConclusion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConclusion(v)
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckMutation) AddedFields() []string {
	var fields []string
	if m.addrepo_id != nil {
		fields = append(fields, check.FieldRepoID)
	}
	if m.addpull_request_id != nil {
		fields = append(fields, check.FieldPullRequestID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case check.FieldRepoID:
		return m.AddedRepoID()
	case check.FieldPullRequestID:
		return m.AddedPullRequestID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) AddField(name string, value ent.Value) error {
	switch name {
	case check.FieldRepoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepoID(v)
		return nil
	case check.FieldPullRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPullRequestID(v)
		return nil
	}
	return fmt.Errorf("unknown Check numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(check.FieldConclusion) {
		fields = append(fields, check.FieldConclusion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckMutation) ClearField(name string) error {
	switch name {
	case check.FieldConclusion:
		m.ClearConclusion()
		return nil
	}
	return fmt.Errorf("unknown Check nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckMutation) ResetField(name string) error {
	switch name {
	case check.FieldRepoID:
		m.ResetRepoID()
		return nil
	case check.FieldPullRequestID:
		m.ResetPullRequestID()
		return nil
	case check.FieldName:
		m.ResetName()
		return nil
	case check.FieldStatus:
		m.ResetStatus()
		return nil
	case check.FieldConclusion:
		m.ResetConclusion()
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Check unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Check edge %s", name)
}

// GPTDialogMutation represents an operation that mutates the GPTDialog nodes in the graph.
type GPTDialogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	peer_id              *string
	prompt_msg_id        *int
	addprompt_msg_id     *int
	prompt_msg           *string
	gpt_msg_id           *int
	addgpt_msg_id        *int
	gpt_msg              *string
	thread_top_msg_id    *int
	addthread_top_msg_id *int
	created_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*GPTDialog, error)
	predicates           []predicate.GPTDialog
}

var _ ent.Mutation = (*GPTDialogMutation)(nil)

// gptdialogOption allows management of the mutation configuration using functional options.
type gptdialogOption func(*GPTDialogMutation)

// newGPTDialogMutation creates new mutation for the GPTDialog entity.
func newGPTDialogMutation(c config, op Op, opts ...gptdialogOption) *GPTDialogMutation {
	m := &GPTDialogMutation{
		config:        c,
		op:            op,
		typ:           TypeGPTDialog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGPTDialogID sets the ID field of the mutation.
func withGPTDialogID(id int) gptdialogOption {
	return func(m *GPTDialogMutation) {
		var (
			err   error
			once  sync.Once
			value *GPTDialog
		)
		m.oldValue = func(ctx context.Context) (*GPTDialog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GPTDialog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGPTDialog sets the old GPTDialog of the mutation.
func withGPTDialog(node *GPTDialog) gptdialogOption {
	return func(m *GPTDialogMutation) {
		m.oldValue = func(context.Context) (*GPTDialog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GPTDialogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GPTDialogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GPTDialogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GPTDialogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GPTDialog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPeerID sets the "peer_id" field.
func (m *GPTDialogMutation) SetPeerID(s string) {
	m.peer_id = &s
}

// PeerID returns the value of the "peer_id" field in the mutation.
func (m *GPTDialogMutation) PeerID() (r string, exists bool) {
	v := m.peer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPeerID returns the old "peer_id" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldPeerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeerID: %w", err)
	}
	return oldValue.PeerID, nil
}

// ResetPeerID resets all changes to the "peer_id" field.
func (m *GPTDialogMutation) ResetPeerID() {
	m.peer_id = nil
}

// SetPromptMsgID sets the "prompt_msg_id" field.
func (m *GPTDialogMutation) SetPromptMsgID(i int) {
	m.prompt_msg_id = &i
	m.addprompt_msg_id = nil
}

// PromptMsgID returns the value of the "prompt_msg_id" field in the mutation.
func (m *GPTDialogMutation) PromptMsgID() (r int, exists bool) {
	v := m.prompt_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptMsgID returns the old "prompt_msg_id" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldPromptMsgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptMsgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptMsgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptMsgID: %w", err)
	}
	return oldValue.PromptMsgID, nil
}

// AddPromptMsgID adds i to the "prompt_msg_id" field.
func (m *GPTDialogMutation) AddPromptMsgID(i int) {
	if m.addprompt_msg_id != nil {
		*m.addprompt_msg_id += i
	} else {
		m.addprompt_msg_id = &i
	}
}

// AddedPromptMsgID returns the value that was added to the "prompt_msg_id" field in this mutation.
func (m *GPTDialogMutation) AddedPromptMsgID() (r int, exists bool) {
	v := m.addprompt_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromptMsgID resets all changes to the "prompt_msg_id" field.
func (m *GPTDialogMutation) ResetPromptMsgID() {
	m.prompt_msg_id = nil
	m.addprompt_msg_id = nil
}

// SetPromptMsg sets the "prompt_msg" field.
func (m *GPTDialogMutation) SetPromptMsg(s string) {
	m.prompt_msg = &s
}

// PromptMsg returns the value of the "prompt_msg" field in the mutation.
func (m *GPTDialogMutation) PromptMsg() (r string, exists bool) {
	v := m.prompt_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptMsg returns the old "prompt_msg" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldPromptMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptMsg: %w", err)
	}
	return oldValue.PromptMsg, nil
}

// ResetPromptMsg resets all changes to the "prompt_msg" field.
func (m *GPTDialogMutation) ResetPromptMsg() {
	m.prompt_msg = nil
}

// SetGptMsgID sets the "gpt_msg_id" field.
func (m *GPTDialogMutation) SetGptMsgID(i int) {
	m.gpt_msg_id = &i
	m.addgpt_msg_id = nil
}

// GptMsgID returns the value of the "gpt_msg_id" field in the mutation.
func (m *GPTDialogMutation) GptMsgID() (r int, exists bool) {
	v := m.gpt_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGptMsgID returns the old "gpt_msg_id" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldGptMsgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGptMsgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGptMsgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGptMsgID: %w", err)
	}
	return oldValue.GptMsgID, nil
}

// AddGptMsgID adds i to the "gpt_msg_id" field.
func (m *GPTDialogMutation) AddGptMsgID(i int) {
	if m.addgpt_msg_id != nil {
		*m.addgpt_msg_id += i
	} else {
		m.addgpt_msg_id = &i
	}
}

// AddedGptMsgID returns the value that was added to the "gpt_msg_id" field in this mutation.
func (m *GPTDialogMutation) AddedGptMsgID() (r int, exists bool) {
	v := m.addgpt_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGptMsgID resets all changes to the "gpt_msg_id" field.
func (m *GPTDialogMutation) ResetGptMsgID() {
	m.gpt_msg_id = nil
	m.addgpt_msg_id = nil
}

// SetGptMsg sets the "gpt_msg" field.
func (m *GPTDialogMutation) SetGptMsg(s string) {
	m.gpt_msg = &s
}

// GptMsg returns the value of the "gpt_msg" field in the mutation.
func (m *GPTDialogMutation) GptMsg() (r string, exists bool) {
	v := m.gpt_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldGptMsg returns the old "gpt_msg" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldGptMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGptMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGptMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGptMsg: %w", err)
	}
	return oldValue.GptMsg, nil
}

// ResetGptMsg resets all changes to the "gpt_msg" field.
func (m *GPTDialogMutation) ResetGptMsg() {
	m.gpt_msg = nil
}

// SetThreadTopMsgID sets the "thread_top_msg_id" field.
func (m *GPTDialogMutation) SetThreadTopMsgID(i int) {
	m.thread_top_msg_id = &i
	m.addthread_top_msg_id = nil
}

// ThreadTopMsgID returns the value of the "thread_top_msg_id" field in the mutation.
func (m *GPTDialogMutation) ThreadTopMsgID() (r int, exists bool) {
	v := m.thread_top_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadTopMsgID returns the old "thread_top_msg_id" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldThreadTopMsgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadTopMsgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadTopMsgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadTopMsgID: %w", err)
	}
	return oldValue.ThreadTopMsgID, nil
}

// AddThreadTopMsgID adds i to the "thread_top_msg_id" field.
func (m *GPTDialogMutation) AddThreadTopMsgID(i int) {
	if m.addthread_top_msg_id != nil {
		*m.addthread_top_msg_id += i
	} else {
		m.addthread_top_msg_id = &i
	}
}

// AddedThreadTopMsgID returns the value that was added to the "thread_top_msg_id" field in this mutation.
func (m *GPTDialogMutation) AddedThreadTopMsgID() (r int, exists bool) {
	v := m.addthread_top_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearThreadTopMsgID clears the value of the "thread_top_msg_id" field.
func (m *GPTDialogMutation) ClearThreadTopMsgID() {
	m.thread_top_msg_id = nil
	m.addthread_top_msg_id = nil
	m.clearedFields[gptdialog.FieldThreadTopMsgID] = struct{}{}
}

// ThreadTopMsgIDCleared returns if the "thread_top_msg_id" field was cleared in this mutation.
func (m *GPTDialogMutation) ThreadTopMsgIDCleared() bool {
	_, ok := m.clearedFields[gptdialog.FieldThreadTopMsgID]
	return ok
}

// ResetThreadTopMsgID resets all changes to the "thread_top_msg_id" field.
func (m *GPTDialogMutation) ResetThreadTopMsgID() {
	m.thread_top_msg_id = nil
	m.addthread_top_msg_id = nil
	delete(m.clearedFields, gptdialog.FieldThreadTopMsgID)
}

// SetCreatedAt sets the "created_at" field.
func (m *GPTDialogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GPTDialogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GPTDialogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the GPTDialogMutation builder.
func (m *GPTDialogMutation) Where(ps ...predicate.GPTDialog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GPTDialogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GPTDialogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GPTDialog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GPTDialogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GPTDialogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GPTDialog).
func (m *GPTDialogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GPTDialogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.peer_id != nil {
		fields = append(fields, gptdialog.FieldPeerID)
	}
	if m.prompt_msg_id != nil {
		fields = append(fields, gptdialog.FieldPromptMsgID)
	}
	if m.prompt_msg != nil {
		fields = append(fields, gptdialog.FieldPromptMsg)
	}
	if m.gpt_msg_id != nil {
		fields = append(fields, gptdialog.FieldGptMsgID)
	}
	if m.gpt_msg != nil {
		fields = append(fields, gptdialog.FieldGptMsg)
	}
	if m.thread_top_msg_id != nil {
		fields = append(fields, gptdialog.FieldThreadTopMsgID)
	}
	if m.created_at != nil {
		fields = append(fields, gptdialog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GPTDialogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gptdialog.FieldPeerID:
		return m.PeerID()
	case gptdialog.FieldPromptMsgID:
		return m.PromptMsgID()
	case gptdialog.FieldPromptMsg:
		return m.PromptMsg()
	case gptdialog.FieldGptMsgID:
		return m.GptMsgID()
	case gptdialog.FieldGptMsg:
		return m.GptMsg()
	case gptdialog.FieldThreadTopMsgID:
		return m.ThreadTopMsgID()
	case gptdialog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GPTDialogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gptdialog.FieldPeerID:
		return m.OldPeerID(ctx)
	case gptdialog.FieldPromptMsgID:
		return m.OldPromptMsgID(ctx)
	case gptdialog.FieldPromptMsg:
		return m.OldPromptMsg(ctx)
	case gptdialog.FieldGptMsgID:
		return m.OldGptMsgID(ctx)
	case gptdialog.FieldGptMsg:
		return m.OldGptMsg(ctx)
	case gptdialog.FieldThreadTopMsgID:
		return m.OldThreadTopMsgID(ctx)
	case gptdialog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GPTDialog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GPTDialogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gptdialog.FieldPeerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeerID(v)
		return nil
	case gptdialog.FieldPromptMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptMsgID(v)
		return nil
	case gptdialog.FieldPromptMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptMsg(v)
		return nil
	case gptdialog.FieldGptMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGptMsgID(v)
		return nil
	case gptdialog.FieldGptMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGptMsg(v)
		return nil
	case gptdialog.FieldThreadTopMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadTopMsgID(v)
		return nil
	case gptdialog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GPTDialog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GPTDialogMutation) AddedFields() []string {
	var fields []string
	if m.addprompt_msg_id != nil {
		fields = append(fields, gptdialog.FieldPromptMsgID)
	}
	if m.addgpt_msg_id != nil {
		fields = append(fields, gptdialog.FieldGptMsgID)
	}
	if m.addthread_top_msg_id != nil {
		fields = append(fields, gptdialog.FieldThreadTopMsgID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GPTDialogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gptdialog.FieldPromptMsgID:
		return m.AddedPromptMsgID()
	case gptdialog.FieldGptMsgID:
		return m.AddedGptMsgID()
	case gptdialog.FieldThreadTopMsgID:
		return m.AddedThreadTopMsgID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GPTDialogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gptdialog.FieldPromptMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptMsgID(v)
		return nil
	case gptdialog.FieldGptMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGptMsgID(v)
		return nil
	case gptdialog.FieldThreadTopMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThreadTopMsgID(v)
		return nil
	}
	return fmt.Errorf("unknown GPTDialog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GPTDialogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gptdialog.FieldThreadTopMsgID) {
		fields = append(fields, gptdialog.FieldThreadTopMsgID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GPTDialogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GPTDialogMutation) ClearField(name string) error {
	switch name {
	case gptdialog.FieldThreadTopMsgID:
		m.ClearThreadTopMsgID()
		return nil
	}
	return fmt.Errorf("unknown GPTDialog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GPTDialogMutation) ResetField(name string) error {
	switch name {
	case gptdialog.FieldPeerID:
		m.ResetPeerID()
		return nil
	case gptdialog.FieldPromptMsgID:
		m.ResetPromptMsgID()
		return nil
	case gptdialog.FieldPromptMsg:
		m.ResetPromptMsg()
		return nil
	case gptdialog.FieldGptMsgID:
		m.ResetGptMsgID()
		return nil
	case gptdialog.FieldGptMsg:
		m.ResetGptMsg()
		return nil
	case gptdialog.FieldThreadTopMsgID:
		m.ResetThreadTopMsgID()
		return nil
	case gptdialog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GPTDialog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GPTDialogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GPTDialogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GPTDialogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GPTDialogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GPTDialogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GPTDialogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GPTDialogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GPTDialog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GPTDialogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GPTDialog edge %s", name)
}

// LastChannelMessageMutation represents an operation that mutates the LastChannelMessage nodes in the graph.
type LastChannelMessageMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	message_id    *int
	addmessage_id *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LastChannelMessage, error)
	predicates    []predicate.LastChannelMessage
}

var _ ent.Mutation = (*LastChannelMessageMutation)(nil)

// lastchannelmessageOption allows management of the mutation configuration using functional options.
type lastchannelmessageOption func(*LastChannelMessageMutation)

// newLastChannelMessageMutation creates new mutation for the LastChannelMessage entity.
func newLastChannelMessageMutation(c config, op Op, opts ...lastchannelmessageOption) *LastChannelMessageMutation {
	m := &LastChannelMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeLastChannelMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLastChannelMessageID sets the ID field of the mutation.
func withLastChannelMessageID(id int64) lastchannelmessageOption {
	return func(m *LastChannelMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *LastChannelMessage
		)
		m.oldValue = func(ctx context.Context) (*LastChannelMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LastChannelMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLastChannelMessage sets the old LastChannelMessage of the mutation.
func withLastChannelMessage(node *LastChannelMessage) lastchannelmessageOption {
	return func(m *LastChannelMessageMutation) {
		m.oldValue = func(context.Context) (*LastChannelMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LastChannelMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LastChannelMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LastChannelMessage entities.
func (m *LastChannelMessageMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LastChannelMessageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LastChannelMessageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LastChannelMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMessageID sets the "message_id" field.
func (m *LastChannelMessageMutation) SetMessageID(i int) {
	m.message_id = &i
	m.addmessage_id = nil
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *LastChannelMessageMutation) MessageID() (r int, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the LastChannelMessage entity.
// If the LastChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LastChannelMessageMutation) OldMessageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// AddMessageID adds i to the "message_id" field.
func (m *LastChannelMessageMutation) AddMessageID(i int) {
	if m.addmessage_id != nil {
		*m.addmessage_id += i
	} else {
		m.addmessage_id = &i
	}
}

// AddedMessageID returns the value that was added to the "message_id" field in this mutation.
func (m *LastChannelMessageMutation) AddedMessageID() (r int, exists bool) {
	v := m.addmessage_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *LastChannelMessageMutation) ResetMessageID() {
	m.message_id = nil
	m.addmessage_id = nil
}

// Where appends a list predicates to the LastChannelMessageMutation builder.
func (m *LastChannelMessageMutation) Where(ps ...predicate.LastChannelMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LastChannelMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LastChannelMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LastChannelMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LastChannelMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LastChannelMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LastChannelMessage).
func (m *LastChannelMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LastChannelMessageMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.message_id != nil {
		fields = append(fields, lastchannelmessage.FieldMessageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LastChannelMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lastchannelmessage.FieldMessageID:
		return m.MessageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LastChannelMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lastchannelmessage.FieldMessageID:
		return m.OldMessageID(ctx)
	}
	return nil, fmt.Errorf("unknown LastChannelMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LastChannelMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lastchannelmessage.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown LastChannelMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LastChannelMessageMutation) AddedFields() []string {
	var fields []string
	if m.addmessage_id != nil {
		fields = append(fields, lastchannelmessage.FieldMessageID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LastChannelMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lastchannelmessage.FieldMessageID:
		return m.AddedMessageID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LastChannelMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lastchannelmessage.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown LastChannelMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LastChannelMessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LastChannelMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LastChannelMessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LastChannelMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LastChannelMessageMutation) ResetField(name string) error {
	switch name {
	case lastchannelmessage.FieldMessageID:
		m.ResetMessageID()
		return nil
	}
	return fmt.Errorf("unknown LastChannelMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LastChannelMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LastChannelMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LastChannelMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LastChannelMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LastChannelMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LastChannelMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LastChannelMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LastChannelMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LastChannelMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LastChannelMessage edge %s", name)
}

// PRNotificationMutation represents an operation that mutates the PRNotification nodes in the graph.
type PRNotificationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	repo_id                   *int64
	addrepo_id                *int64
	pull_request_id           *int
	addpull_request_id        *int
	pull_request_title        *string
	pull_request_body         *string
	pull_request_author_login *string
	message_id                *int
	addmessage_id             *int
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*PRNotification, error)
	predicates                []predicate.PRNotification
}

var _ ent.Mutation = (*PRNotificationMutation)(nil)

// prnotificationOption allows management of the mutation configuration using functional options.
type prnotificationOption func(*PRNotificationMutation)

// newPRNotificationMutation creates new mutation for the PRNotification entity.
func newPRNotificationMutation(c config, op Op, opts ...prnotificationOption) *PRNotificationMutation {
	m := &PRNotificationMutation{
		config:        c,
		op:            op,
		typ:           TypePRNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPRNotificationID sets the ID field of the mutation.
func withPRNotificationID(id int) prnotificationOption {
	return func(m *PRNotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *PRNotification
		)
		m.oldValue = func(ctx context.Context) (*PRNotification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PRNotification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPRNotification sets the old PRNotification of the mutation.
func withPRNotification(node *PRNotification) prnotificationOption {
	return func(m *PRNotificationMutation) {
		m.oldValue = func(context.Context) (*PRNotification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PRNotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PRNotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PRNotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PRNotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PRNotification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepoID sets the "repo_id" field.
func (m *PRNotificationMutation) SetRepoID(i int64) {
	m.repo_id = &i
	m.addrepo_id = nil
}

// RepoID returns the value of the "repo_id" field in the mutation.
func (m *PRNotificationMutation) RepoID() (r int64, exists bool) {
	v := m.repo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoID returns the old "repo_id" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldRepoID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoID: %w", err)
	}
	return oldValue.RepoID, nil
}

// AddRepoID adds i to the "repo_id" field.
func (m *PRNotificationMutation) AddRepoID(i int64) {
	if m.addrepo_id != nil {
		*m.addrepo_id += i
	} else {
		m.addrepo_id = &i
	}
}

// AddedRepoID returns the value that was added to the "repo_id" field in this mutation.
func (m *PRNotificationMutation) AddedRepoID() (r int64, exists bool) {
	v := m.addrepo_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepoID resets all changes to the "repo_id" field.
func (m *PRNotificationMutation) ResetRepoID() {
	m.repo_id = nil
	m.addrepo_id = nil
}

// SetPullRequestID sets the "pull_request_id" field.
func (m *PRNotificationMutation) SetPullRequestID(i int) {
	m.pull_request_id = &i
	m.addpull_request_id = nil
}

// PullRequestID returns the value of the "pull_request_id" field in the mutation.
func (m *PRNotificationMutation) PullRequestID() (r int, exists bool) {
	v := m.pull_request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestID returns the old "pull_request_id" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldPullRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestID: %w", err)
	}
	return oldValue.PullRequestID, nil
}

// AddPullRequestID adds i to the "pull_request_id" field.
func (m *PRNotificationMutation) AddPullRequestID(i int) {
	if m.addpull_request_id != nil {
		*m.addpull_request_id += i
	} else {
		m.addpull_request_id = &i
	}
}

// AddedPullRequestID returns the value that was added to the "pull_request_id" field in this mutation.
func (m *PRNotificationMutation) AddedPullRequestID() (r int, exists bool) {
	v := m.addpull_request_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPullRequestID resets all changes to the "pull_request_id" field.
func (m *PRNotificationMutation) ResetPullRequestID() {
	m.pull_request_id = nil
	m.addpull_request_id = nil
}

// SetPullRequestTitle sets the "pull_request_title" field.
func (m *PRNotificationMutation) SetPullRequestTitle(s string) {
	m.pull_request_title = &s
}

// PullRequestTitle returns the value of the "pull_request_title" field in the mutation.
func (m *PRNotificationMutation) PullRequestTitle() (r string, exists bool) {
	v := m.pull_request_title
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestTitle returns the old "pull_request_title" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldPullRequestTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullRequestTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullRequestTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestTitle: %w", err)
	}
	return oldValue.PullRequestTitle, nil
}

// ResetPullRequestTitle resets all changes to the "pull_request_title" field.
func (m *PRNotificationMutation) ResetPullRequestTitle() {
	m.pull_request_title = nil
}

// SetPullRequestBody sets the "pull_request_body" field.
func (m *PRNotificationMutation) SetPullRequestBody(s string) {
	m.pull_request_body = &s
}

// PullRequestBody returns the value of the "pull_request_body" field in the mutation.
func (m *PRNotificationMutation) PullRequestBody() (r string, exists bool) {
	v := m.pull_request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestBody returns the old "pull_request_body" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldPullRequestBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestBody: %w", err)
	}
	return oldValue.PullRequestBody, nil
}

// ResetPullRequestBody resets all changes to the "pull_request_body" field.
func (m *PRNotificationMutation) ResetPullRequestBody() {
	m.pull_request_body = nil
}

// SetPullRequestAuthorLogin sets the "pull_request_author_login" field.
func (m *PRNotificationMutation) SetPullRequestAuthorLogin(s string) {
	m.pull_request_author_login = &s
}

// PullRequestAuthorLogin returns the value of the "pull_request_author_login" field in the mutation.
func (m *PRNotificationMutation) PullRequestAuthorLogin() (r string, exists bool) {
	v := m.pull_request_author_login
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestAuthorLogin returns the old "pull_request_author_login" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldPullRequestAuthorLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullRequestAuthorLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullRequestAuthorLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestAuthorLogin: %w", err)
	}
	return oldValue.PullRequestAuthorLogin, nil
}

// ResetPullRequestAuthorLogin resets all changes to the "pull_request_author_login" field.
func (m *PRNotificationMutation) ResetPullRequestAuthorLogin() {
	m.pull_request_author_login = nil
}

// SetMessageID sets the "message_id" field.
func (m *PRNotificationMutation) SetMessageID(i int) {
	m.message_id = &i
	m.addmessage_id = nil
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *PRNotificationMutation) MessageID() (r int, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldMessageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// AddMessageID adds i to the "message_id" field.
func (m *PRNotificationMutation) AddMessageID(i int) {
	if m.addmessage_id != nil {
		*m.addmessage_id += i
	} else {
		m.addmessage_id = &i
	}
}

// AddedMessageID returns the value that was added to the "message_id" field in this mutation.
func (m *PRNotificationMutation) AddedMessageID() (r int, exists bool) {
	v := m.addmessage_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *PRNotificationMutation) ResetMessageID() {
	m.message_id = nil
	m.addmessage_id = nil
}

// Where appends a list predicates to the PRNotificationMutation builder.
func (m *PRNotificationMutation) Where(ps ...predicate.PRNotification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PRNotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PRNotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PRNotification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PRNotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PRNotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PRNotification).
func (m *PRNotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PRNotificationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.repo_id != nil {
		fields = append(fields, prnotification.FieldRepoID)
	}
	if m.pull_request_id != nil {
		fields = append(fields, prnotification.FieldPullRequestID)
	}
	if m.pull_request_title != nil {
		fields = append(fields, prnotification.FieldPullRequestTitle)
	}
	if m.pull_request_body != nil {
		fields = append(fields, prnotification.FieldPullRequestBody)
	}
	if m.pull_request_author_login != nil {
		fields = append(fields, prnotification.FieldPullRequestAuthorLogin)
	}
	if m.message_id != nil {
		fields = append(fields, prnotification.FieldMessageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PRNotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prnotification.FieldRepoID:
		return m.RepoID()
	case prnotification.FieldPullRequestID:
		return m.PullRequestID()
	case prnotification.FieldPullRequestTitle:
		return m.PullRequestTitle()
	case prnotification.FieldPullRequestBody:
		return m.PullRequestBody()
	case prnotification.FieldPullRequestAuthorLogin:
		return m.PullRequestAuthorLogin()
	case prnotification.FieldMessageID:
		return m.MessageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PRNotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prnotification.FieldRepoID:
		return m.OldRepoID(ctx)
	case prnotification.FieldPullRequestID:
		return m.OldPullRequestID(ctx)
	case prnotification.FieldPullRequestTitle:
		return m.OldPullRequestTitle(ctx)
	case prnotification.FieldPullRequestBody:
		return m.OldPullRequestBody(ctx)
	case prnotification.FieldPullRequestAuthorLogin:
		return m.OldPullRequestAuthorLogin(ctx)
	case prnotification.FieldMessageID:
		return m.OldMessageID(ctx)
	}
	return nil, fmt.Errorf("unknown PRNotification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PRNotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prnotification.FieldRepoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoID(v)
		return nil
	case prnotification.FieldPullRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestID(v)
		return nil
	case prnotification.FieldPullRequestTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestTitle(v)
		return nil
	case prnotification.FieldPullRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestBody(v)
		return nil
	case prnotification.FieldPullRequestAuthorLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestAuthorLogin(v)
		return nil
	case prnotification.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown PRNotification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PRNotificationMutation) AddedFields() []string {
	var fields []string
	if m.addrepo_id != nil {
		fields = append(fields, prnotification.FieldRepoID)
	}
	if m.addpull_request_id != nil {
		fields = append(fields, prnotification.FieldPullRequestID)
	}
	if m.addmessage_id != nil {
		fields = append(fields, prnotification.FieldMessageID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PRNotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prnotification.FieldRepoID:
		return m.AddedRepoID()
	case prnotification.FieldPullRequestID:
		return m.AddedPullRequestID()
	case prnotification.FieldMessageID:
		return m.AddedMessageID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PRNotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prnotification.FieldRepoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepoID(v)
		return nil
	case prnotification.FieldPullRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPullRequestID(v)
		return nil
	case prnotification.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown PRNotification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PRNotificationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PRNotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PRNotificationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PRNotification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PRNotificationMutation) ResetField(name string) error {
	switch name {
	case prnotification.FieldRepoID:
		m.ResetRepoID()
		return nil
	case prnotification.FieldPullRequestID:
		m.ResetPullRequestID()
		return nil
	case prnotification.FieldPullRequestTitle:
		m.ResetPullRequestTitle()
		return nil
	case prnotification.FieldPullRequestBody:
		m.ResetPullRequestBody()
		return nil
	case prnotification.FieldPullRequestAuthorLogin:
		m.ResetPullRequestAuthorLogin()
		return nil
	case prnotification.FieldMessageID:
		m.ResetMessageID()
		return nil
	}
	return fmt.Errorf("unknown PRNotification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PRNotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PRNotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PRNotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PRNotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PRNotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PRNotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PRNotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PRNotification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PRNotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PRNotification edge %s", name)
}

// TelegramChannelStateMutation represents an operation that mutates the TelegramChannelState nodes in the graph.
type TelegramChannelStateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	channel_id    *int64
	addchannel_id *int64
	pts           *int
	addpts        *int
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*TelegramChannelState, error)
	predicates    []predicate.TelegramChannelState
}

var _ ent.Mutation = (*TelegramChannelStateMutation)(nil)

// telegramchannelstateOption allows management of the mutation configuration using functional options.
type telegramchannelstateOption func(*TelegramChannelStateMutation)

// newTelegramChannelStateMutation creates new mutation for the TelegramChannelState entity.
func newTelegramChannelStateMutation(c config, op Op, opts ...telegramchannelstateOption) *TelegramChannelStateMutation {
	m := &TelegramChannelStateMutation{
		config:        c,
		op:            op,
		typ:           TypeTelegramChannelState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTelegramChannelStateID sets the ID field of the mutation.
func withTelegramChannelStateID(id int) telegramchannelstateOption {
	return func(m *TelegramChannelStateMutation) {
		var (
			err   error
			once  sync.Once
			value *TelegramChannelState
		)
		m.oldValue = func(ctx context.Context) (*TelegramChannelState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TelegramChannelState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTelegramChannelState sets the old TelegramChannelState of the mutation.
func withTelegramChannelState(node *TelegramChannelState) telegramchannelstateOption {
	return func(m *TelegramChannelStateMutation) {
		m.oldValue = func(context.Context) (*TelegramChannelState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TelegramChannelStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TelegramChannelStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TelegramChannelStateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TelegramChannelStateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TelegramChannelState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannelID sets the "channel_id" field.
func (m *TelegramChannelStateMutation) SetChannelID(i int64) {
	m.channel_id = &i
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *TelegramChannelStateMutation) ChannelID() (r int64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the TelegramChannelState entity.
// If the TelegramChannelState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramChannelStateMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds i to the "channel_id" field.
func (m *TelegramChannelStateMutation) AddChannelID(i int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += i
	} else {
		m.addchannel_id = &i
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *TelegramChannelStateMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *TelegramChannelStateMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetUserID sets the "user_id" field.
func (m *TelegramChannelStateMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TelegramChannelStateMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TelegramChannelState entity.
// If the TelegramChannelState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramChannelStateMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TelegramChannelStateMutation) ResetUserID() {
	m.user = nil
}

// SetPts sets the "pts" field.
func (m *TelegramChannelStateMutation) SetPts(i int) {
	m.pts = &i
	m.addpts = nil
}

// Pts returns the value of the "pts" field in the mutation.
func (m *TelegramChannelStateMutation) Pts() (r int, exists bool) {
	v := m.pts
	if v == nil {
		return
	}
	return *v, true
}

// OldPts returns the old "pts" field's value of the TelegramChannelState entity.
// If the TelegramChannelState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramChannelStateMutation) OldPts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPts: %w", err)
	}
	return oldValue.Pts, nil
}

// AddPts adds i to the "pts" field.
func (m *TelegramChannelStateMutation) AddPts(i int) {
	if m.addpts != nil {
		*m.addpts += i
	} else {
		m.addpts = &i
	}
}

// AddedPts returns the value that was added to the "pts" field in this mutation.
func (m *TelegramChannelStateMutation) AddedPts() (r int, exists bool) {
	v := m.addpts
	if v == nil {
		return
	}
	return *v, true
}

// ResetPts resets all changes to the "pts" field.
func (m *TelegramChannelStateMutation) ResetPts() {
	m.pts = nil
	m.addpts = nil
}

// ClearUser clears the "user" edge to the TelegramUserState entity.
func (m *TelegramChannelStateMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the TelegramUserState entity was cleared.
func (m *TelegramChannelStateMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TelegramChannelStateMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TelegramChannelStateMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TelegramChannelStateMutation builder.
func (m *TelegramChannelStateMutation) Where(ps ...predicate.TelegramChannelState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TelegramChannelStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TelegramChannelStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TelegramChannelState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TelegramChannelStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TelegramChannelStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TelegramChannelState).
func (m *TelegramChannelStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TelegramChannelStateMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.channel_id != nil {
		fields = append(fields, telegramchannelstate.FieldChannelID)
	}
	if m.user != nil {
		fields = append(fields, telegramchannelstate.FieldUserID)
	}
	if m.pts != nil {
		fields = append(fields, telegramchannelstate.FieldPts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TelegramChannelStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case telegramchannelstate.FieldChannelID:
		return m.ChannelID()
	case telegramchannelstate.FieldUserID:
		return m.UserID()
	case telegramchannelstate.FieldPts:
		return m.Pts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TelegramChannelStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case telegramchannelstate.FieldChannelID:
		return m.OldChannelID(ctx)
	case telegramchannelstate.FieldUserID:
		return m.OldUserID(ctx)
	case telegramchannelstate.FieldPts:
		return m.OldPts(ctx)
	}
	return nil, fmt.Errorf("unknown TelegramChannelState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelegramChannelStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case telegramchannelstate.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case telegramchannelstate.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case telegramchannelstate.FieldPts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPts(v)
		return nil
	}
	return fmt.Errorf("unknown TelegramChannelState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TelegramChannelStateMutation) AddedFields() []string {
	var fields []string
	if m.addchannel_id != nil {
		fields = append(fields, telegramchannelstate.FieldChannelID)
	}
	if m.addpts != nil {
		fields = append(fields, telegramchannelstate.FieldPts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TelegramChannelStateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case telegramchannelstate.FieldChannelID:
		return m.AddedChannelID()
	case telegramchannelstate.FieldPts:
		return m.AddedPts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelegramChannelStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case telegramchannelstate.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	case telegramchannelstate.FieldPts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPts(v)
		return nil
	}
	return fmt.Errorf("unknown TelegramChannelState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TelegramChannelStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TelegramChannelStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TelegramChannelStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TelegramChannelState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TelegramChannelStateMutation) ResetField(name string) error {
	switch name {
	case telegramchannelstate.FieldChannelID:
		m.ResetChannelID()
		return nil
	case telegramchannelstate.FieldUserID:
		m.ResetUserID()
		return nil
	case telegramchannelstate.FieldPts:
		m.ResetPts()
		return nil
	}
	return fmt.Errorf("unknown TelegramChannelState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TelegramChannelStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, telegramchannelstate.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TelegramChannelStateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case telegramchannelstate.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TelegramChannelStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TelegramChannelStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TelegramChannelStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, telegramchannelstate.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TelegramChannelStateMutation) EdgeCleared(name string) bool {
	switch name {
	case telegramchannelstate.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TelegramChannelStateMutation) ClearEdge(name string) error {
	switch name {
	case telegramchannelstate.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TelegramChannelState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TelegramChannelStateMutation) ResetEdge(name string) error {
	switch name {
	case telegramchannelstate.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TelegramChannelState edge %s", name)
}

// TelegramSessionMutation represents an operation that mutates the TelegramSession nodes in the graph.
type TelegramSessionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	data          *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TelegramSession, error)
	predicates    []predicate.TelegramSession
}

var _ ent.Mutation = (*TelegramSessionMutation)(nil)

// telegramsessionOption allows management of the mutation configuration using functional options.
type telegramsessionOption func(*TelegramSessionMutation)

// newTelegramSessionMutation creates new mutation for the TelegramSession entity.
func newTelegramSessionMutation(c config, op Op, opts ...telegramsessionOption) *TelegramSessionMutation {
	m := &TelegramSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeTelegramSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTelegramSessionID sets the ID field of the mutation.
func withTelegramSessionID(id uuid.UUID) telegramsessionOption {
	return func(m *TelegramSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *TelegramSession
		)
		m.oldValue = func(ctx context.Context) (*TelegramSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TelegramSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTelegramSession sets the old TelegramSession of the mutation.
func withTelegramSession(node *TelegramSession) telegramsessionOption {
	return func(m *TelegramSessionMutation) {
		m.oldValue = func(context.Context) (*TelegramSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TelegramSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TelegramSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TelegramSession entities.
func (m *TelegramSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TelegramSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TelegramSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TelegramSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetData sets the "data" field.
func (m *TelegramSessionMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *TelegramSessionMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the TelegramSession entity.
// If the TelegramSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramSessionMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *TelegramSessionMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the TelegramSessionMutation builder.
func (m *TelegramSessionMutation) Where(ps ...predicate.TelegramSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TelegramSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TelegramSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TelegramSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TelegramSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TelegramSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TelegramSession).
func (m *TelegramSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TelegramSessionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.data != nil {
		fields = append(fields, telegramsession.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TelegramSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case telegramsession.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TelegramSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case telegramsession.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown TelegramSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelegramSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case telegramsession.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown TelegramSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TelegramSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TelegramSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelegramSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TelegramSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TelegramSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TelegramSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TelegramSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TelegramSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TelegramSessionMutation) ResetField(name string) error {
	switch name {
	case telegramsession.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown TelegramSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TelegramSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TelegramSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TelegramSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TelegramSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TelegramSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TelegramSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TelegramSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TelegramSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TelegramSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TelegramSession edge %s", name)
}

// TelegramUserStateMutation represents an operation that mutates the TelegramUserState nodes in the graph.
type TelegramUserStateMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	qts             *int
	addqts          *int
	pts             *int
	addpts          *int
	date            *int
	adddate         *int
	seq             *int
	addseq          *int
	clearedFields   map[string]struct{}
	channels        map[int]struct{}
	removedchannels map[int]struct{}
	clearedchannels bool
	done            bool
	oldValue        func(context.Context) (*TelegramUserState, error)
	predicates      []predicate.TelegramUserState
}

var _ ent.Mutation = (*TelegramUserStateMutation)(nil)

// telegramuserstateOption allows management of the mutation configuration using functional options.
type telegramuserstateOption func(*TelegramUserStateMutation)

// newTelegramUserStateMutation creates new mutation for the TelegramUserState entity.
func newTelegramUserStateMutation(c config, op Op, opts ...telegramuserstateOption) *TelegramUserStateMutation {
	m := &TelegramUserStateMutation{
		config:        c,
		op:            op,
		typ:           TypeTelegramUserState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTelegramUserStateID sets the ID field of the mutation.
func withTelegramUserStateID(id int64) telegramuserstateOption {
	return func(m *TelegramUserStateMutation) {
		var (
			err   error
			once  sync.Once
			value *TelegramUserState
		)
		m.oldValue = func(ctx context.Context) (*TelegramUserState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TelegramUserState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTelegramUserState sets the old TelegramUserState of the mutation.
func withTelegramUserState(node *TelegramUserState) telegramuserstateOption {
	return func(m *TelegramUserStateMutation) {
		m.oldValue = func(context.Context) (*TelegramUserState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TelegramUserStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TelegramUserStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TelegramUserState entities.
func (m *TelegramUserStateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TelegramUserStateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TelegramUserStateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TelegramUserState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQts sets the "qts" field.
func (m *TelegramUserStateMutation) SetQts(i int) {
	m.qts = &i
	m.addqts = nil
}

// Qts returns the value of the "qts" field in the mutation.
func (m *TelegramUserStateMutation) Qts() (r int, exists bool) {
	v := m.qts
	if v == nil {
		return
	}
	return *v, true
}

// OldQts returns the old "qts" field's value of the TelegramUserState entity.
// If the TelegramUserState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramUserStateMutation) OldQts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQts: %w", err)
	}
	return oldValue.Qts, nil
}

// AddQts adds i to the "qts" field.
func (m *TelegramUserStateMutation) AddQts(i int) {
	if m.addqts != nil {
		*m.addqts += i
	} else {
		m.addqts = &i
	}
}

// AddedQts returns the value that was added to the "qts" field in this mutation.
func (m *TelegramUserStateMutation) AddedQts() (r int, exists bool) {
	v := m.addqts
	if v == nil {
		return
	}
	return *v, true
}

// ResetQts resets all changes to the "qts" field.
func (m *TelegramUserStateMutation) ResetQts() {
	m.qts = nil
	m.addqts = nil
}

// SetPts sets the "pts" field.
func (m *TelegramUserStateMutation) SetPts(i int) {
	m.pts = &i
	m.addpts = nil
}

// Pts returns the value of the "pts" field in the mutation.
func (m *TelegramUserStateMutation) Pts() (r int, exists bool) {
	v := m.pts
	if v == nil {
		return
	}
	return *v, true
}

// OldPts returns the old "pts" field's value of the TelegramUserState entity.
// If the TelegramUserState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramUserStateMutation) OldPts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPts: %w", err)
	}
	return oldValue.Pts, nil
}

// AddPts adds i to the "pts" field.
func (m *TelegramUserStateMutation) AddPts(i int) {
	if m.addpts != nil {
		*m.addpts += i
	} else {
		m.addpts = &i
	}
}

// AddedPts returns the value that was added to the "pts" field in this mutation.
func (m *TelegramUserStateMutation) AddedPts() (r int, exists bool) {
	v := m.addpts
	if v == nil {
		return
	}
	return *v, true
}

// ResetPts resets all changes to the "pts" field.
func (m *TelegramUserStateMutation) ResetPts() {
	m.pts = nil
	m.addpts = nil
}

// SetDate sets the "date" field.
func (m *TelegramUserStateMutation) SetDate(i int) {
	m.date = &i
	m.adddate = nil
}

// Date returns the value of the "date" field in the mutation.
func (m *TelegramUserStateMutation) Date() (r int, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the TelegramUserState entity.
// If the TelegramUserState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramUserStateMutation) OldDate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to the "date" field.
func (m *TelegramUserStateMutation) AddDate(i int) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the "date" field in this mutation.
func (m *TelegramUserStateMutation) AddedDate() (r int, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate resets all changes to the "date" field.
func (m *TelegramUserStateMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetSeq sets the "seq" field.
func (m *TelegramUserStateMutation) SetSeq(i int) {
	m.seq = &i
	m.addseq = nil
}

// Seq returns the value of the "seq" field in the mutation.
func (m *TelegramUserStateMutation) Seq() (r int, exists bool) {
	v := m.seq
	if v == nil {
		return
	}
	return *v, true
}

// OldSeq returns the old "seq" field's value of the TelegramUserState entity.
// If the TelegramUserState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramUserStateMutation) OldSeq(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeq: %w", err)
	}
	return oldValue.Seq, nil
}

// AddSeq adds i to the "seq" field.
func (m *TelegramUserStateMutation) AddSeq(i int) {
	if m.addseq != nil {
		*m.addseq += i
	} else {
		m.addseq = &i
	}
}

// AddedSeq returns the value that was added to the "seq" field in this mutation.
func (m *TelegramUserStateMutation) AddedSeq() (r int, exists bool) {
	v := m.addseq
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeq resets all changes to the "seq" field.
func (m *TelegramUserStateMutation) ResetSeq() {
	m.seq = nil
	m.addseq = nil
}

// AddChannelIDs adds the "channels" edge to the TelegramChannelState entity by ids.
func (m *TelegramUserStateMutation) AddChannelIDs(ids ...int) {
	if m.channels == nil {
		m.channels = make(map[int]struct{})
	}
	for i := range ids {
		m.channels[ids[i]] = struct{}{}
	}
}

// ClearChannels clears the "channels" edge to the TelegramChannelState entity.
func (m *TelegramUserStateMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the TelegramChannelState entity was cleared.
func (m *TelegramUserStateMutation) ChannelsCleared() bool {
	return m.clearedchannels
}

// RemoveChannelIDs removes the "channels" edge to the TelegramChannelState entity by IDs.
func (m *TelegramUserStateMutation) RemoveChannelIDs(ids ...int) {
	if m.removedchannels == nil {
		m.removedchannels = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.channels, ids[i])
		m.removedchannels[ids[i]] = struct{}{}
	}
}

// RemovedChannels returns the removed IDs of the "channels" edge to the TelegramChannelState entity.
func (m *TelegramUserStateMutation) RemovedChannelsIDs() (ids []int) {
	for id := range m.removedchannels {
		ids = append(ids, id)
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
func (m *TelegramUserStateMutation) ChannelsIDs() (ids []int) {
	for id := range m.channels {
		ids = append(ids, id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *TelegramUserStateMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
	m.removedchannels = nil
}

// Where appends a list predicates to the TelegramUserStateMutation builder.
func (m *TelegramUserStateMutation) Where(ps ...predicate.TelegramUserState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TelegramUserStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TelegramUserStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TelegramUserState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TelegramUserStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TelegramUserStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TelegramUserState).
func (m *TelegramUserStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TelegramUserStateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.qts != nil {
		fields = append(fields, telegramuserstate.FieldQts)
	}
	if m.pts != nil {
		fields = append(fields, telegramuserstate.FieldPts)
	}
	if m.date != nil {
		fields = append(fields, telegramuserstate.FieldDate)
	}
	if m.seq != nil {
		fields = append(fields, telegramuserstate.FieldSeq)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TelegramUserStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case telegramuserstate.FieldQts:
		return m.Qts()
	case telegramuserstate.FieldPts:
		return m.Pts()
	case telegramuserstate.FieldDate:
		return m.Date()
	case telegramuserstate.FieldSeq:
		return m.Seq()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TelegramUserStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case telegramuserstate.FieldQts:
		return m.OldQts(ctx)
	case telegramuserstate.FieldPts:
		return m.OldPts(ctx)
	case telegramuserstate.FieldDate:
		return m.OldDate(ctx)
	case telegramuserstate.FieldSeq:
		return m.OldSeq(ctx)
	}
	return nil, fmt.Errorf("unknown TelegramUserState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelegramUserStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case telegramuserstate.FieldQts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQts(v)
		return nil
	case telegramuserstate.FieldPts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPts(v)
		return nil
	case telegramuserstate.FieldDate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case telegramuserstate.FieldSeq:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeq(v)
		return nil
	}
	return fmt.Errorf("unknown TelegramUserState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TelegramUserStateMutation) AddedFields() []string {
	var fields []string
	if m.addqts != nil {
		fields = append(fields, telegramuserstate.FieldQts)
	}
	if m.addpts != nil {
		fields = append(fields, telegramuserstate.FieldPts)
	}
	if m.adddate != nil {
		fields = append(fields, telegramuserstate.FieldDate)
	}
	if m.addseq != nil {
		fields = append(fields, telegramuserstate.FieldSeq)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TelegramUserStateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case telegramuserstate.FieldQts:
		return m.AddedQts()
	case telegramuserstate.FieldPts:
		return m.AddedPts()
	case telegramuserstate.FieldDate:
		return m.AddedDate()
	case telegramuserstate.FieldSeq:
		return m.AddedSeq()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelegramUserStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case telegramuserstate.FieldQts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQts(v)
		return nil
	case telegramuserstate.FieldPts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPts(v)
		return nil
	case telegramuserstate.FieldDate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case telegramuserstate.FieldSeq:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeq(v)
		return nil
	}
	return fmt.Errorf("unknown TelegramUserState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TelegramUserStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TelegramUserStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TelegramUserStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TelegramUserState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TelegramUserStateMutation) ResetField(name string) error {
	switch name {
	case telegramuserstate.FieldQts:
		m.ResetQts()
		return nil
	case telegramuserstate.FieldPts:
		m.ResetPts()
		return nil
	case telegramuserstate.FieldDate:
		m.ResetDate()
		return nil
	case telegramuserstate.FieldSeq:
		m.ResetSeq()
		return nil
	}
	return fmt.Errorf("unknown TelegramUserState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TelegramUserStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.channels != nil {
		edges = append(edges, telegramuserstate.EdgeChannels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TelegramUserStateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case telegramuserstate.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.channels))
		for id := range m.channels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TelegramUserStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedchannels != nil {
		edges = append(edges, telegramuserstate.EdgeChannels)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TelegramUserStateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case telegramuserstate.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.removedchannels))
		for id := range m.removedchannels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TelegramUserStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchannels {
		edges = append(edges, telegramuserstate.EdgeChannels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TelegramUserStateMutation) EdgeCleared(name string) bool {
	switch name {
	case telegramuserstate.EdgeChannels:
		return m.clearedchannels
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TelegramUserStateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TelegramUserState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TelegramUserStateMutation) ResetEdge(name string) error {
	switch name {
	case telegramuserstate.EdgeChannels:
		m.ResetChannels()
		return nil
	}
	return fmt.Errorf("unknown TelegramUserState edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	username      *string
	first_name    *string
	last_name     *string
	github_token  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetGithubToken sets the "github_token" field.
func (m *UserMutation) SetGithubToken(s string) {
	m.github_token = &s
}

// GithubToken returns the value of the "github_token" field in the mutation.
func (m *UserMutation) GithubToken() (r string, exists bool) {
	v := m.github_token
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubToken returns the old "github_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGithubToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubToken: %w", err)
	}
	return oldValue.GithubToken, nil
}

// ClearGithubToken clears the value of the "github_token" field.
func (m *UserMutation) ClearGithubToken() {
	m.github_token = nil
	m.clearedFields[user.FieldGithubToken] = struct{}{}
}

// GithubTokenCleared returns if the "github_token" field was cleared in this mutation.
func (m *UserMutation) GithubTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldGithubToken]
	return ok
}

// ResetGithubToken resets all changes to the "github_token" field.
func (m *UserMutation) ResetGithubToken() {
	m.github_token = nil
	delete(m.clearedFields, user.FieldGithubToken)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.github_token != nil {
		fields = append(fields, user.FieldGithubToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldGithubToken:
		return m.GithubToken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldGithubToken:
		return m.OldGithubToken(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldGithubToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubToken(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldGithubToken) {
		fields = append(fields, user.FieldGithubToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldGithubToken:
		m.ClearGithubToken()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldGithubToken:
		m.ResetGithubToken()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/go-faster/bot/internal/ent/gptdialog"
	"github.com/go-faster/bot/internal/ent/lastchannelmessage"
	"github.com/go-faster/bot/internal/ent/predicate"
	"github.com/go-faster/bot/internal/ent/prnotification"
	"github.com/go-faster/bot/internal/ent/telegramsession"
	"github.com/go-faster/bot/internal/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGPTDialog          = "GPTDialog"
	TypeLastChannelMessage = "LastChannelMessage"
	TypePRNotification     = "PRNotification"
	TypeTelegramSession    = "TelegramSession"
	TypeUser               = "User"
)

// GPTDialogMutation represents an operation that mutates the GPTDialog nodes in the graph.
type GPTDialogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	peer_id              *string
	prompt_msg_id        *int
	addprompt_msg_id     *int
	prompt_msg           *string
	gpt_msg_id           *int
	addgpt_msg_id        *int
	gpt_msg              *string
	thread_top_msg_id    *int
	addthread_top_msg_id *int
	created_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*GPTDialog, error)
	predicates           []predicate.GPTDialog
}

var _ ent.Mutation = (*GPTDialogMutation)(nil)

// gptdialogOption allows management of the mutation configuration using functional options.
type gptdialogOption func(*GPTDialogMutation)

// newGPTDialogMutation creates new mutation for the GPTDialog entity.
func newGPTDialogMutation(c config, op Op, opts ...gptdialogOption) *GPTDialogMutation {
	m := &GPTDialogMutation{
		config:        c,
		op:            op,
		typ:           TypeGPTDialog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGPTDialogID sets the ID field of the mutation.
func withGPTDialogID(id int) gptdialogOption {
	return func(m *GPTDialogMutation) {
		var (
			err   error
			once  sync.Once
			value *GPTDialog
		)
		m.oldValue = func(ctx context.Context) (*GPTDialog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GPTDialog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGPTDialog sets the old GPTDialog of the mutation.
func withGPTDialog(node *GPTDialog) gptdialogOption {
	return func(m *GPTDialogMutation) {
		m.oldValue = func(context.Context) (*GPTDialog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GPTDialogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GPTDialogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GPTDialogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GPTDialogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GPTDialog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPeerID sets the "peer_id" field.
func (m *GPTDialogMutation) SetPeerID(s string) {
	m.peer_id = &s
}

// PeerID returns the value of the "peer_id" field in the mutation.
func (m *GPTDialogMutation) PeerID() (r string, exists bool) {
	v := m.peer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPeerID returns the old "peer_id" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldPeerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeerID: %w", err)
	}
	return oldValue.PeerID, nil
}

// ResetPeerID resets all changes to the "peer_id" field.
func (m *GPTDialogMutation) ResetPeerID() {
	m.peer_id = nil
}

// SetPromptMsgID sets the "prompt_msg_id" field.
func (m *GPTDialogMutation) SetPromptMsgID(i int) {
	m.prompt_msg_id = &i
	m.addprompt_msg_id = nil
}

// PromptMsgID returns the value of the "prompt_msg_id" field in the mutation.
func (m *GPTDialogMutation) PromptMsgID() (r int, exists bool) {
	v := m.prompt_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptMsgID returns the old "prompt_msg_id" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldPromptMsgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptMsgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptMsgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptMsgID: %w", err)
	}
	return oldValue.PromptMsgID, nil
}

// AddPromptMsgID adds i to the "prompt_msg_id" field.
func (m *GPTDialogMutation) AddPromptMsgID(i int) {
	if m.addprompt_msg_id != nil {
		*m.addprompt_msg_id += i
	} else {
		m.addprompt_msg_id = &i
	}
}

// AddedPromptMsgID returns the value that was added to the "prompt_msg_id" field in this mutation.
func (m *GPTDialogMutation) AddedPromptMsgID() (r int, exists bool) {
	v := m.addprompt_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromptMsgID resets all changes to the "prompt_msg_id" field.
func (m *GPTDialogMutation) ResetPromptMsgID() {
	m.prompt_msg_id = nil
	m.addprompt_msg_id = nil
}

// SetPromptMsg sets the "prompt_msg" field.
func (m *GPTDialogMutation) SetPromptMsg(s string) {
	m.prompt_msg = &s
}

// PromptMsg returns the value of the "prompt_msg" field in the mutation.
func (m *GPTDialogMutation) PromptMsg() (r string, exists bool) {
	v := m.prompt_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptMsg returns the old "prompt_msg" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldPromptMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptMsg: %w", err)
	}
	return oldValue.PromptMsg, nil
}

// ResetPromptMsg resets all changes to the "prompt_msg" field.
func (m *GPTDialogMutation) ResetPromptMsg() {
	m.prompt_msg = nil
}

// SetGptMsgID sets the "gpt_msg_id" field.
func (m *GPTDialogMutation) SetGptMsgID(i int) {
	m.gpt_msg_id = &i
	m.addgpt_msg_id = nil
}

// GptMsgID returns the value of the "gpt_msg_id" field in the mutation.
func (m *GPTDialogMutation) GptMsgID() (r int, exists bool) {
	v := m.gpt_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGptMsgID returns the old "gpt_msg_id" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldGptMsgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGptMsgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGptMsgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGptMsgID: %w", err)
	}
	return oldValue.GptMsgID, nil
}

// AddGptMsgID adds i to the "gpt_msg_id" field.
func (m *GPTDialogMutation) AddGptMsgID(i int) {
	if m.addgpt_msg_id != nil {
		*m.addgpt_msg_id += i
	} else {
		m.addgpt_msg_id = &i
	}
}

// AddedGptMsgID returns the value that was added to the "gpt_msg_id" field in this mutation.
func (m *GPTDialogMutation) AddedGptMsgID() (r int, exists bool) {
	v := m.addgpt_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGptMsgID resets all changes to the "gpt_msg_id" field.
func (m *GPTDialogMutation) ResetGptMsgID() {
	m.gpt_msg_id = nil
	m.addgpt_msg_id = nil
}

// SetGptMsg sets the "gpt_msg" field.
func (m *GPTDialogMutation) SetGptMsg(s string) {
	m.gpt_msg = &s
}

// GptMsg returns the value of the "gpt_msg" field in the mutation.
func (m *GPTDialogMutation) GptMsg() (r string, exists bool) {
	v := m.gpt_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldGptMsg returns the old "gpt_msg" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldGptMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGptMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGptMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGptMsg: %w", err)
	}
	return oldValue.GptMsg, nil
}

// ResetGptMsg resets all changes to the "gpt_msg" field.
func (m *GPTDialogMutation) ResetGptMsg() {
	m.gpt_msg = nil
}

// SetThreadTopMsgID sets the "thread_top_msg_id" field.
func (m *GPTDialogMutation) SetThreadTopMsgID(i int) {
	m.thread_top_msg_id = &i
	m.addthread_top_msg_id = nil
}

// ThreadTopMsgID returns the value of the "thread_top_msg_id" field in the mutation.
func (m *GPTDialogMutation) ThreadTopMsgID() (r int, exists bool) {
	v := m.thread_top_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadTopMsgID returns the old "thread_top_msg_id" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldThreadTopMsgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadTopMsgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadTopMsgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadTopMsgID: %w", err)
	}
	return oldValue.ThreadTopMsgID, nil
}

// AddThreadTopMsgID adds i to the "thread_top_msg_id" field.
func (m *GPTDialogMutation) AddThreadTopMsgID(i int) {
	if m.addthread_top_msg_id != nil {
		*m.addthread_top_msg_id += i
	} else {
		m.addthread_top_msg_id = &i
	}
}

// AddedThreadTopMsgID returns the value that was added to the "thread_top_msg_id" field in this mutation.
func (m *GPTDialogMutation) AddedThreadTopMsgID() (r int, exists bool) {
	v := m.addthread_top_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearThreadTopMsgID clears the value of the "thread_top_msg_id" field.
func (m *GPTDialogMutation) ClearThreadTopMsgID() {
	m.thread_top_msg_id = nil
	m.addthread_top_msg_id = nil
	m.clearedFields[gptdialog.FieldThreadTopMsgID] = struct{}{}
}

// ThreadTopMsgIDCleared returns if the "thread_top_msg_id" field was cleared in this mutation.
func (m *GPTDialogMutation) ThreadTopMsgIDCleared() bool {
	_, ok := m.clearedFields[gptdialog.FieldThreadTopMsgID]
	return ok
}

// ResetThreadTopMsgID resets all changes to the "thread_top_msg_id" field.
func (m *GPTDialogMutation) ResetThreadTopMsgID() {
	m.thread_top_msg_id = nil
	m.addthread_top_msg_id = nil
	delete(m.clearedFields, gptdialog.FieldThreadTopMsgID)
}

// SetCreatedAt sets the "created_at" field.
func (m *GPTDialogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GPTDialogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GPTDialog entity.
// If the GPTDialog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GPTDialogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GPTDialogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the GPTDialogMutation builder.
func (m *GPTDialogMutation) Where(ps ...predicate.GPTDialog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GPTDialogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GPTDialogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GPTDialog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GPTDialogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GPTDialogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GPTDialog).
func (m *GPTDialogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GPTDialogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.peer_id != nil {
		fields = append(fields, gptdialog.FieldPeerID)
	}
	if m.prompt_msg_id != nil {
		fields = append(fields, gptdialog.FieldPromptMsgID)
	}
	if m.prompt_msg != nil {
		fields = append(fields, gptdialog.FieldPromptMsg)
	}
	if m.gpt_msg_id != nil {
		fields = append(fields, gptdialog.FieldGptMsgID)
	}
	if m.gpt_msg != nil {
		fields = append(fields, gptdialog.FieldGptMsg)
	}
	if m.thread_top_msg_id != nil {
		fields = append(fields, gptdialog.FieldThreadTopMsgID)
	}
	if m.created_at != nil {
		fields = append(fields, gptdialog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GPTDialogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gptdialog.FieldPeerID:
		return m.PeerID()
	case gptdialog.FieldPromptMsgID:
		return m.PromptMsgID()
	case gptdialog.FieldPromptMsg:
		return m.PromptMsg()
	case gptdialog.FieldGptMsgID:
		return m.GptMsgID()
	case gptdialog.FieldGptMsg:
		return m.GptMsg()
	case gptdialog.FieldThreadTopMsgID:
		return m.ThreadTopMsgID()
	case gptdialog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GPTDialogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gptdialog.FieldPeerID:
		return m.OldPeerID(ctx)
	case gptdialog.FieldPromptMsgID:
		return m.OldPromptMsgID(ctx)
	case gptdialog.FieldPromptMsg:
		return m.OldPromptMsg(ctx)
	case gptdialog.FieldGptMsgID:
		return m.OldGptMsgID(ctx)
	case gptdialog.FieldGptMsg:
		return m.OldGptMsg(ctx)
	case gptdialog.FieldThreadTopMsgID:
		return m.OldThreadTopMsgID(ctx)
	case gptdialog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GPTDialog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GPTDialogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gptdialog.FieldPeerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeerID(v)
		return nil
	case gptdialog.FieldPromptMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptMsgID(v)
		return nil
	case gptdialog.FieldPromptMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptMsg(v)
		return nil
	case gptdialog.FieldGptMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGptMsgID(v)
		return nil
	case gptdialog.FieldGptMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGptMsg(v)
		return nil
	case gptdialog.FieldThreadTopMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadTopMsgID(v)
		return nil
	case gptdialog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GPTDialog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GPTDialogMutation) AddedFields() []string {
	var fields []string
	if m.addprompt_msg_id != nil {
		fields = append(fields, gptdialog.FieldPromptMsgID)
	}
	if m.addgpt_msg_id != nil {
		fields = append(fields, gptdialog.FieldGptMsgID)
	}
	if m.addthread_top_msg_id != nil {
		fields = append(fields, gptdialog.FieldThreadTopMsgID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GPTDialogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gptdialog.FieldPromptMsgID:
		return m.AddedPromptMsgID()
	case gptdialog.FieldGptMsgID:
		return m.AddedGptMsgID()
	case gptdialog.FieldThreadTopMsgID:
		return m.AddedThreadTopMsgID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GPTDialogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gptdialog.FieldPromptMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptMsgID(v)
		return nil
	case gptdialog.FieldGptMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGptMsgID(v)
		return nil
	case gptdialog.FieldThreadTopMsgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThreadTopMsgID(v)
		return nil
	}
	return fmt.Errorf("unknown GPTDialog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GPTDialogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gptdialog.FieldThreadTopMsgID) {
		fields = append(fields, gptdialog.FieldThreadTopMsgID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GPTDialogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GPTDialogMutation) ClearField(name string) error {
	switch name {
	case gptdialog.FieldThreadTopMsgID:
		m.ClearThreadTopMsgID()
		return nil
	}
	return fmt.Errorf("unknown GPTDialog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GPTDialogMutation) ResetField(name string) error {
	switch name {
	case gptdialog.FieldPeerID:
		m.ResetPeerID()
		return nil
	case gptdialog.FieldPromptMsgID:
		m.ResetPromptMsgID()
		return nil
	case gptdialog.FieldPromptMsg:
		m.ResetPromptMsg()
		return nil
	case gptdialog.FieldGptMsgID:
		m.ResetGptMsgID()
		return nil
	case gptdialog.FieldGptMsg:
		m.ResetGptMsg()
		return nil
	case gptdialog.FieldThreadTopMsgID:
		m.ResetThreadTopMsgID()
		return nil
	case gptdialog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GPTDialog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GPTDialogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GPTDialogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GPTDialogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GPTDialogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GPTDialogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GPTDialogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GPTDialogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GPTDialog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GPTDialogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GPTDialog edge %s", name)
}

// LastChannelMessageMutation represents an operation that mutates the LastChannelMessage nodes in the graph.
type LastChannelMessageMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	message_id    *int
	addmessage_id *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LastChannelMessage, error)
	predicates    []predicate.LastChannelMessage
}

var _ ent.Mutation = (*LastChannelMessageMutation)(nil)

// lastchannelmessageOption allows management of the mutation configuration using functional options.
type lastchannelmessageOption func(*LastChannelMessageMutation)

// newLastChannelMessageMutation creates new mutation for the LastChannelMessage entity.
func newLastChannelMessageMutation(c config, op Op, opts ...lastchannelmessageOption) *LastChannelMessageMutation {
	m := &LastChannelMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeLastChannelMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLastChannelMessageID sets the ID field of the mutation.
func withLastChannelMessageID(id int64) lastchannelmessageOption {
	return func(m *LastChannelMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *LastChannelMessage
		)
		m.oldValue = func(ctx context.Context) (*LastChannelMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LastChannelMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLastChannelMessage sets the old LastChannelMessage of the mutation.
func withLastChannelMessage(node *LastChannelMessage) lastchannelmessageOption {
	return func(m *LastChannelMessageMutation) {
		m.oldValue = func(context.Context) (*LastChannelMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LastChannelMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LastChannelMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LastChannelMessage entities.
func (m *LastChannelMessageMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LastChannelMessageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LastChannelMessageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LastChannelMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMessageID sets the "message_id" field.
func (m *LastChannelMessageMutation) SetMessageID(i int) {
	m.message_id = &i
	m.addmessage_id = nil
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *LastChannelMessageMutation) MessageID() (r int, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the LastChannelMessage entity.
// If the LastChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LastChannelMessageMutation) OldMessageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// AddMessageID adds i to the "message_id" field.
func (m *LastChannelMessageMutation) AddMessageID(i int) {
	if m.addmessage_id != nil {
		*m.addmessage_id += i
	} else {
		m.addmessage_id = &i
	}
}

// AddedMessageID returns the value that was added to the "message_id" field in this mutation.
func (m *LastChannelMessageMutation) AddedMessageID() (r int, exists bool) {
	v := m.addmessage_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *LastChannelMessageMutation) ResetMessageID() {
	m.message_id = nil
	m.addmessage_id = nil
}

// Where appends a list predicates to the LastChannelMessageMutation builder.
func (m *LastChannelMessageMutation) Where(ps ...predicate.LastChannelMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LastChannelMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LastChannelMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LastChannelMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LastChannelMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LastChannelMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LastChannelMessage).
func (m *LastChannelMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LastChannelMessageMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.message_id != nil {
		fields = append(fields, lastchannelmessage.FieldMessageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LastChannelMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lastchannelmessage.FieldMessageID:
		return m.MessageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LastChannelMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lastchannelmessage.FieldMessageID:
		return m.OldMessageID(ctx)
	}
	return nil, fmt.Errorf("unknown LastChannelMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LastChannelMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lastchannelmessage.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown LastChannelMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LastChannelMessageMutation) AddedFields() []string {
	var fields []string
	if m.addmessage_id != nil {
		fields = append(fields, lastchannelmessage.FieldMessageID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LastChannelMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lastchannelmessage.FieldMessageID:
		return m.AddedMessageID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LastChannelMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lastchannelmessage.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown LastChannelMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LastChannelMessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LastChannelMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LastChannelMessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LastChannelMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LastChannelMessageMutation) ResetField(name string) error {
	switch name {
	case lastchannelmessage.FieldMessageID:
		m.ResetMessageID()
		return nil
	}
	return fmt.Errorf("unknown LastChannelMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LastChannelMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LastChannelMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LastChannelMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LastChannelMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LastChannelMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LastChannelMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LastChannelMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LastChannelMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LastChannelMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LastChannelMessage edge %s", name)
}

// PRNotificationMutation represents an operation that mutates the PRNotification nodes in the graph.
type PRNotificationMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	repo_id            *int64
	addrepo_id         *int64
	pull_request_id    *int
	addpull_request_id *int
	message_id         *int
	addmessage_id      *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*PRNotification, error)
	predicates         []predicate.PRNotification
}

var _ ent.Mutation = (*PRNotificationMutation)(nil)

// prnotificationOption allows management of the mutation configuration using functional options.
type prnotificationOption func(*PRNotificationMutation)

// newPRNotificationMutation creates new mutation for the PRNotification entity.
func newPRNotificationMutation(c config, op Op, opts ...prnotificationOption) *PRNotificationMutation {
	m := &PRNotificationMutation{
		config:        c,
		op:            op,
		typ:           TypePRNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPRNotificationID sets the ID field of the mutation.
func withPRNotificationID(id int) prnotificationOption {
	return func(m *PRNotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *PRNotification
		)
		m.oldValue = func(ctx context.Context) (*PRNotification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PRNotification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPRNotification sets the old PRNotification of the mutation.
func withPRNotification(node *PRNotification) prnotificationOption {
	return func(m *PRNotificationMutation) {
		m.oldValue = func(context.Context) (*PRNotification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PRNotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PRNotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PRNotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PRNotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PRNotification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepoID sets the "repo_id" field.
func (m *PRNotificationMutation) SetRepoID(i int64) {
	m.repo_id = &i
	m.addrepo_id = nil
}

// RepoID returns the value of the "repo_id" field in the mutation.
func (m *PRNotificationMutation) RepoID() (r int64, exists bool) {
	v := m.repo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoID returns the old "repo_id" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldRepoID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoID: %w", err)
	}
	return oldValue.RepoID, nil
}

// AddRepoID adds i to the "repo_id" field.
func (m *PRNotificationMutation) AddRepoID(i int64) {
	if m.addrepo_id != nil {
		*m.addrepo_id += i
	} else {
		m.addrepo_id = &i
	}
}

// AddedRepoID returns the value that was added to the "repo_id" field in this mutation.
func (m *PRNotificationMutation) AddedRepoID() (r int64, exists bool) {
	v := m.addrepo_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepoID resets all changes to the "repo_id" field.
func (m *PRNotificationMutation) ResetRepoID() {
	m.repo_id = nil
	m.addrepo_id = nil
}

// SetPullRequestID sets the "pull_request_id" field.
func (m *PRNotificationMutation) SetPullRequestID(i int) {
	m.pull_request_id = &i
	m.addpull_request_id = nil
}

// PullRequestID returns the value of the "pull_request_id" field in the mutation.
func (m *PRNotificationMutation) PullRequestID() (r int, exists bool) {
	v := m.pull_request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPullRequestID returns the old "pull_request_id" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldPullRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullRequestID: %w", err)
	}
	return oldValue.PullRequestID, nil
}

// AddPullRequestID adds i to the "pull_request_id" field.
func (m *PRNotificationMutation) AddPullRequestID(i int) {
	if m.addpull_request_id != nil {
		*m.addpull_request_id += i
	} else {
		m.addpull_request_id = &i
	}
}

// AddedPullRequestID returns the value that was added to the "pull_request_id" field in this mutation.
func (m *PRNotificationMutation) AddedPullRequestID() (r int, exists bool) {
	v := m.addpull_request_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPullRequestID resets all changes to the "pull_request_id" field.
func (m *PRNotificationMutation) ResetPullRequestID() {
	m.pull_request_id = nil
	m.addpull_request_id = nil
}

// SetMessageID sets the "message_id" field.
func (m *PRNotificationMutation) SetMessageID(i int) {
	m.message_id = &i
	m.addmessage_id = nil
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *PRNotificationMutation) MessageID() (r int, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the PRNotification entity.
// If the PRNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PRNotificationMutation) OldMessageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// AddMessageID adds i to the "message_id" field.
func (m *PRNotificationMutation) AddMessageID(i int) {
	if m.addmessage_id != nil {
		*m.addmessage_id += i
	} else {
		m.addmessage_id = &i
	}
}

// AddedMessageID returns the value that was added to the "message_id" field in this mutation.
func (m *PRNotificationMutation) AddedMessageID() (r int, exists bool) {
	v := m.addmessage_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *PRNotificationMutation) ResetMessageID() {
	m.message_id = nil
	m.addmessage_id = nil
}

// Where appends a list predicates to the PRNotificationMutation builder.
func (m *PRNotificationMutation) Where(ps ...predicate.PRNotification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PRNotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PRNotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PRNotification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PRNotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PRNotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PRNotification).
func (m *PRNotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PRNotificationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.repo_id != nil {
		fields = append(fields, prnotification.FieldRepoID)
	}
	if m.pull_request_id != nil {
		fields = append(fields, prnotification.FieldPullRequestID)
	}
	if m.message_id != nil {
		fields = append(fields, prnotification.FieldMessageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PRNotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prnotification.FieldRepoID:
		return m.RepoID()
	case prnotification.FieldPullRequestID:
		return m.PullRequestID()
	case prnotification.FieldMessageID:
		return m.MessageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PRNotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prnotification.FieldRepoID:
		return m.OldRepoID(ctx)
	case prnotification.FieldPullRequestID:
		return m.OldPullRequestID(ctx)
	case prnotification.FieldMessageID:
		return m.OldMessageID(ctx)
	}
	return nil, fmt.Errorf("unknown PRNotification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PRNotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prnotification.FieldRepoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoID(v)
		return nil
	case prnotification.FieldPullRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullRequestID(v)
		return nil
	case prnotification.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown PRNotification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PRNotificationMutation) AddedFields() []string {
	var fields []string
	if m.addrepo_id != nil {
		fields = append(fields, prnotification.FieldRepoID)
	}
	if m.addpull_request_id != nil {
		fields = append(fields, prnotification.FieldPullRequestID)
	}
	if m.addmessage_id != nil {
		fields = append(fields, prnotification.FieldMessageID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PRNotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prnotification.FieldRepoID:
		return m.AddedRepoID()
	case prnotification.FieldPullRequestID:
		return m.AddedPullRequestID()
	case prnotification.FieldMessageID:
		return m.AddedMessageID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PRNotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prnotification.FieldRepoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepoID(v)
		return nil
	case prnotification.FieldPullRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPullRequestID(v)
		return nil
	case prnotification.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown PRNotification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PRNotificationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PRNotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PRNotificationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PRNotification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PRNotificationMutation) ResetField(name string) error {
	switch name {
	case prnotification.FieldRepoID:
		m.ResetRepoID()
		return nil
	case prnotification.FieldPullRequestID:
		m.ResetPullRequestID()
		return nil
	case prnotification.FieldMessageID:
		m.ResetMessageID()
		return nil
	}
	return fmt.Errorf("unknown PRNotification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PRNotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PRNotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PRNotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PRNotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PRNotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PRNotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PRNotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PRNotification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PRNotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PRNotification edge %s", name)
}

// TelegramSessionMutation represents an operation that mutates the TelegramSession nodes in the graph.
type TelegramSessionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	data          *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TelegramSession, error)
	predicates    []predicate.TelegramSession
}

var _ ent.Mutation = (*TelegramSessionMutation)(nil)

// telegramsessionOption allows management of the mutation configuration using functional options.
type telegramsessionOption func(*TelegramSessionMutation)

// newTelegramSessionMutation creates new mutation for the TelegramSession entity.
func newTelegramSessionMutation(c config, op Op, opts ...telegramsessionOption) *TelegramSessionMutation {
	m := &TelegramSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeTelegramSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTelegramSessionID sets the ID field of the mutation.
func withTelegramSessionID(id uuid.UUID) telegramsessionOption {
	return func(m *TelegramSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *TelegramSession
		)
		m.oldValue = func(ctx context.Context) (*TelegramSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TelegramSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTelegramSession sets the old TelegramSession of the mutation.
func withTelegramSession(node *TelegramSession) telegramsessionOption {
	return func(m *TelegramSessionMutation) {
		m.oldValue = func(context.Context) (*TelegramSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TelegramSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TelegramSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TelegramSession entities.
func (m *TelegramSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TelegramSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TelegramSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TelegramSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetData sets the "data" field.
func (m *TelegramSessionMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *TelegramSessionMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the TelegramSession entity.
// If the TelegramSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelegramSessionMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *TelegramSessionMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the TelegramSessionMutation builder.
func (m *TelegramSessionMutation) Where(ps ...predicate.TelegramSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TelegramSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TelegramSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TelegramSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TelegramSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TelegramSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TelegramSession).
func (m *TelegramSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TelegramSessionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.data != nil {
		fields = append(fields, telegramsession.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TelegramSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case telegramsession.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TelegramSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case telegramsession.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown TelegramSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelegramSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case telegramsession.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown TelegramSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TelegramSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TelegramSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelegramSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TelegramSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TelegramSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TelegramSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TelegramSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TelegramSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TelegramSessionMutation) ResetField(name string) error {
	switch name {
	case telegramsession.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown TelegramSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TelegramSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TelegramSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TelegramSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TelegramSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TelegramSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TelegramSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TelegramSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TelegramSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TelegramSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TelegramSession edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	username      *string
	first_name    *string
	last_name     *string
	github_token  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetGithubToken sets the "github_token" field.
func (m *UserMutation) SetGithubToken(s string) {
	m.github_token = &s
}

// GithubToken returns the value of the "github_token" field in the mutation.
func (m *UserMutation) GithubToken() (r string, exists bool) {
	v := m.github_token
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubToken returns the old "github_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGithubToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubToken: %w", err)
	}
	return oldValue.GithubToken, nil
}

// ClearGithubToken clears the value of the "github_token" field.
func (m *UserMutation) ClearGithubToken() {
	m.github_token = nil
	m.clearedFields[user.FieldGithubToken] = struct{}{}
}

// GithubTokenCleared returns if the "github_token" field was cleared in this mutation.
func (m *UserMutation) GithubTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldGithubToken]
	return ok
}

// ResetGithubToken resets all changes to the "github_token" field.
func (m *UserMutation) ResetGithubToken() {
	m.github_token = nil
	delete(m.clearedFields, user.FieldGithubToken)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.github_token != nil {
		fields = append(fields, user.FieldGithubToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldGithubToken:
		return m.GithubToken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldGithubToken:
		return m.OldGithubToken(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldGithubToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubToken(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldGithubToken) {
		fields = append(fields, user.FieldGithubToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldGithubToken:
		m.ClearGithubToken()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldGithubToken:
		m.ResetGithubToken()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
